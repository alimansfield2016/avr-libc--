#pragma once

#include <stdint.h>
#include <initializer_list>
#include <type_traits>

namespace std
{
	template <class T, uint16_t n_elems>
	class array
	{
	public:
		typedef T value_type;
		typedef value_type *pointer;
		typedef const value_type *const_pointer;
		typedef value_type &reference;
		typedef const value_type &const_reference;
		typedef value_type *iterator;
		typedef const value_type *const_iterator;

		typedef uint16_t size_type;

	private:
		static constexpr size_type count = n_elems;
		value_type m_arr[count];

	public:
		constexpr array(const std::initializer_list<value_type> &init)
			: m_arr{init}
		{
		}
		constexpr array()
			: m_arr()
		{
		}

		constexpr iterator begin() { return &m_arr[0]; }
		constexpr iterator end() { return &m_arr[count]; }
		constexpr const_iterator begin() const { return &m_arr[0]; }
		constexpr const_iterator end() const { return &m_arr[count]; }

		constexpr const_iterator cbegin() const { return &m_arr[0]; }
		constexpr const_iterator cend() const { return &m_arr[count]; }

		constexpr size_type size() const { return count; }

		constexpr reference operator[](size_type idx) { return m_arr[idx]; }
		constexpr const_reference operator[](size_type idx) const { return m_arr[idx]; }
	};

	template<class T>
	class constexpr_vector
	{
	public:
		// using value_type = T;
		using value_type = std::remove_const<T>::type;
		using pointer = value_type*;
		using const_pointer = const T*;
		using iterator = pointer;
		using const_iterator = const T*;
		using reference = value_type&;
		using const_reference = const T&;
		using size_type = size_t;
	private:
		pointer m_ptr;
		const size_type m_size;

	public:
		constexpr constexpr_vector(pointer _ptr, size_type _size) : 
			m_ptr{_ptr}, 
			m_size{_size} {}

		constexpr iterator begin() { return &m_ptr[0]; }
		constexpr iterator end() { return &m_ptr[m_size]; }
		constexpr const_iterator begin() const { return &m_ptr[0]; }
		constexpr const_iterator end() const { return &m_ptr[m_size]; }

		constexpr const_iterator cbegin() const { return &m_ptr[0]; }
		constexpr const_iterator cend() const { return &m_ptr[m_size]; }

		constexpr size_type size() const { return m_size; }

		constexpr reference operator[](size_type idx) { return m_ptr[idx]; }
		constexpr const_reference operator[](size_type idx) const { return m_ptr[idx]; }

	};


	template<class T, size_t S>
	class constexpr_vector_c : public constexpr_vector<T>
	{
		T m_arr[S];

	public:
		constexpr constexpr_vector_c(const std::initializer_list<T> &init) : 
			constexpr_vector<T>{m_arr, S}
			{
				auto it = init.begin();
				for(uint8_t i = 0; i < S && it != init.end(); i++)
					m_arr[i] = *it++;
			}

	};

	template<class T>
	class constexpr_vector_c<T, 0> : public constexpr_vector<T>
	{
	public:
		constexpr constexpr_vector_c(const std::initializer_list<T> &) : 
			constexpr_vector<T>{nullptr, 0}{}
	};

} // namespace std
